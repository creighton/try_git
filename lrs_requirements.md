## LRS Requirements

#### 4.1.1 ID
1.  Ids MUST be generated by the LRS if a Statement is received without an id.

#### 4.1.2.3 Inverse Functional Identifier
1.  Mbox_sha1sum property - The SHA1 hash of a mailto IRI (i.e. the value of an mbox property). An LRS MAY include Agents with a matching hash when a request is based on an mbox.

#### 4.1.2.2 When the Actor ObjectType is Group
1.  A system consuming Statements MUST consider each Anonymous Group distinct even if it has an identical set of members.
2.  A system consuming Statements MUST NOT assume that Agents in the 'member' property comprise an exact list of Agents in a given anonymous or Identified Group.

#### 4.1.3 Verb
1.  A system reading a Statement MUST use the Verb IRI to infer meaning.
2.  A system reading a Statement MUST NOT use the display property to infer any meaning from the Statement.
3.  A system reading a Statement MUST NOT use the display property for any purpose other than display to a human. Using the display property for aggregation or categorization of Statements is an example of violating this requirement.

#### 4.1.4.1 When the ObjectType is Activity
1.  An LRS MUST ignore any information which indicates two authors or organizations may have used the same Activity id.
2.  An LRS MUST NOT treat references to the same id as references to different Activities.
3.  Upon receiving a Statement with an Activity Definition that differs from the one stored, an LRS SHOULD decide whether it considers the Activity Provider to have the authority to change the definition and SHOULD update the stored Activity Definition accordingly if that decision is positive.
4.  An LRS MAY accept small corrections to the Activity’s definition. For example, it would be okay for an LRS to accept spelling fixes, but it may not accept changes to correct responses.
5.  If an Activity IRI is an IRL, an LRS SHOULD attempt to GET that IRL, and include in HTTP headers: "Accept: application/json, /". This SHOULD be done as soon as practical after the LRS first encounters the Activity id.
6.  Upon loading JSON which is a valid Activity Definition from an IRL used as an Activity id, an LRS SHOULD incorporate the loaded definition into its internal definition for that Activity, while preserving names or definitions not included in the loaded definition.
7.  Upon loading any document from which the LRS can parse an Activity Definition from an IRL used as an Activity id, an LRS MAY consider this definition when determining its internal representation of that Activity's definition.
8.  An LRS, upon consuming a valid interactionType, MAY validate the remaining properties as specified in the table below and MAY return HTTP 400 "Bad Request" if the remaining properties are not valid for the Interaction Activity.

#### 4.1.6.2 ContextActivities Property
1.  The LRS MUST return every value in the contextActivities Object as an array, even if it arrived as a single Activity Object.
2.  The LRS MUST return single Activity Objects as an array of length one containing the same Activity.

#### 4.1.7 Timestamp
1.  If not provided, LRS should set this to the value of "stored" time.

#### 4.1.9 Authority
1.  The LRS MUST include the user as an Agent as the entire authority if a user connects directly (using HTTP Basic Authentication) or is included as part of a Group.
2.  The LRS MUST ensure that all Statements stored have an authority.
3.  The LRS SHOULD overwrite the authority on all stored received Statements, based on the credentials used to send those Statements.
4.  The LRS MAY leave the submitted authority unchanged but SHOULD do so only where a strong trust relationship has been established, and with extreme caution.
5.  The LRS MAY identify the user with any of the legal identifying properties if a user connects directly (using HTTP Basic Authentication) or a part of 3-legged OAuth.
6.  An LRS MUST NOT trust the application portion of the authority in the event the account name is from the same source as the unregistered application. (Multiple unregistered applications could choose the same consumer key. As a result, there is no consistent way to verify this combination of temporary credentials and the account name.)

#### 4.1.10 Version.
1.  An LRS MUST accept all Statements where their version starts with "1.0." if they otherwise validate.
2.  An LRS MUST reject all Statements with a version specified that does not start with "1.0.".
3.  Statements returned by an LRS MUST retain the version they are accepted with. If they lack a version, the version MUST be set to 1.0.0.

#### 4.1.11 Attachments
1.  If the LRS accepts the attachment, it can match the raw data of an attachment with the attachment header in a Statement by comparing the SHA-2 of the raw data to the SHA-2 declared in the header. It MUST not do so any other way.
2.  An LRS MUST include attachments in the Transmission Format described above when requested by the Client (see Section7.2 "Statement API").
3.  An LRS MUST NOT pull Statements from another LRS without requesting attachments.
4.  An LRS MUST NOT push Statements into another LRS without including attachment data received, if any, for those attachments.
5.  When receiving a PUT or POST with a document type of "application/json”, an LRS MUST accept batches of Statements which contain no attachment Objects.
6.  When receiving a PUT or POST with a document type of "application/json”, an LRS MUST accept batches of Statements which contain only attachment Objects with a populated fileUrl.
7.  When receiving a PUT or POST with a document type of "multipart/mixed”, an LRS MUST accept batches of Statements that contain attachments in the Transmission Format described above.
8.  When receiving a PUT or POST with a document type of "multipart/mixed”, an LRS MUST reject batches of Statements having attachments that neither contain a fileUrl nor match a received attachment part based on their hash.
9.  When receiving a PUT or POST with a document type of "multipart/mixed”, an LRS SHOULD assume a Content-Transfer-Encoding of binary for attachment parts.
10. An LRS MAY reject (batches of) Statements that are larger than the LRS is configured to allow.

#### 4.1.12 Data Constraints
1.  The LRS MUST reject Statements:
    1.1.    With any null values (except inside extensions).
    1.2.    With strings where numbers are required, even if those strings contain numbers.
    1.3.    With strings where booleans are required, even if those strings contain Booleans.
    1.4.    With any non-format-following key or value, including the empty string, where a. string with a particular format (such as mailto IRI, UUID, or IRI) is required.
    1.5.    Where the case of a key does not match the case specified in the standard.
    1.6.    Where the case of a value restricted to enumerated values does not match an enumerated value given in the standard exactly.
    1.7.    Containing IRL, IRI, or IRI values without a scheme.
2.  The LRS MUST at least validate that the sequence of token lengths for language map keys matches the RFC 5646 standard.
3.  The LRS MUST process and store numbers with at least the precision of IEEE 754 32-bit floating point numbers
4.  The LRS MUST validate parameter values to the same standards required for values of the same types in Statements. Note:string parameter values are not quoted as they are in JSON.
5.  The LRS MAY use best-effort validation for IRL, IRI, and IRI formats to satisfy the non-format-following rejection requirement.
6.  The LRS MAY use best-effort validation for language map keys to satisfy the non-format-following rejection requirement.

#### 4.2 Retrieval of Statements
1.  The IRL retrieved from the more property MUST be usable for at least 24 hours after it is returned by the LRS.
2.  An LRS MAY include all necessary information within the more property IRL to continue the query to avoid the need to store IRLs and associated query data.
3.  An LRS SHOULD NOT generate extremely long IRLs within the more property.

#### 4.3 Voided
1.  Upon receiving a Statement that voids another, the LRS SHOULD reject the entire request which includes the voiding Statement with HTTP 403 'Forbidden' if the request is not from a source authorized to void Statements.
2.  Upon receiving a Statement that voids another, the LRS SHOULD return a descriptive error if the target Statement cannot be found.
3.  Upon receiving a Statement that voids another, the LRS MAY roll back any changes to Activity or Agent definitions which were introduced by the Statement that was just voided.

#### 4.4 Signed Statements
1.  The LRS MUST reject requests to store Statements that contain malformed signatures, with HTTP 400.
2.  The LRS SHOULD include a message in the response of a rejected statement In order to verify signatures are well formed, the LRS MUST do the following:
3.  Decode the JWS signature, and load the signed serialization of the Statement from the JWS signature payload.
4.  Validate that the "original" Statement is logically equivalent to the received Statement (When making this equivalence check, differences which could have been caused by allowed or required LRS processing of "id", "authority", "stored", "timestamp", or "version" MUST be ignored.).
5.  If the JWS header includes an X.509 certificate, validate the signature against that certificate as defined in JWS.

####5.3 Extensions
1.  A learning record store MUST NOT reject an Experience API Statement based on the values of the extensions map.

#### 6.1 Encoding
1.  All strings MUST be encoded and interpreted as UTF-8.

#### 6.2 API Versioning
1.  MUST accept requests with a version header of "1.0" as if the version header was "1.0.0".
2.  MUST reject requests with version header prior to "1.0.0" unless such requests are routed to a fully conformant implementation of the prior version specified in the header.
3.  MUST reject requests with a version header of "1.1.0" or greater.
4.  MUST make these rejects by responding with an HTTP 400 error including a short description of the problem.

#### 6.3 Concurrency
1.  The LRS that responds to a GET request:
    1.1.    MUST add an ETag HTTP header to the response.
    1.2.    MUST calculate the value of this header to be a hexadecimal string of the SHA-1 digest of the contents.
    1.3.    MUST enclose the header in quotes.
2.  The LRS that responds to a PUT request:
    2.1.    MUST handle the If-Match header as described in RFC2616, HTTP 1.1 if it contains an ETag, in order to detect modifications made after the consumer last fetched the document.
    2.2.    MUST handle the If-None-Match header as described in RFC2616, HTTP 1.1 if it contains "*", in order to detect when there is a resource present that the consumer is not aware of.
3.  If the header precondition in either of the above cases fails, the LRS:
    3.1.    MUST return HTTP status 412 "Precondition Failed".
    3.2.    MUST NOT make a modification to the resource.
4.  If a PUT request is received without either header for a resource that already exists, the LRS:
    4.1.    MUST return HTTP status 409 "Conflict".
    4.2.    MUST return a plain text body explaining that the consumer SHOULD:
        4.2.1.  Check the current state of the resource.
        4.2.2.  Set the "If-Match" header with the current ETag to resolve the conflict.
        4.2.3.  MUST NOT make a modification to the resource.

#### 6.4 Security
1.  The LRS MUST support authentication using at least one of the following methods:
    1.1.    OAuth 1.0 (rfc5849), with signature methods of "HMAC-SHA1", "RSA-SHA1", and "PLAINTEXT”
    1.2.    HTTP Basic Authentication
    1.3.    Common Access Cards (implementation details to follow in a later version)
2.  The LRS MUST handle making, or delegating, decisions on the validity of Statements, and determining what operations may be performed based on the credentials used.
3.  No authentication MAY be supported by the LRS, possibly for testing purposes.

#### 6.4.1 How To Handle Each Scenario
1.  General:
    1.1.    The LRS must record the application's name and a unique consumer key (identifier).
    1.2.    The LRS must provide a mechanism to complete this registration, or delegate to another system that provides such a mechanism. The means by which this registration is accomplished are not defined by OAuth or the xAPI.
2.  Application registered + known user:
    2.1.    Use endpoints below to complete the standard workflow.
    2.2.    If this form of authentication is used to record Statements and no authority is specified, the LRS should record the authority as a group consisting of an Agent representing the registered application, and an Agent representing the known user.
3.  Application registered + user unknown:
    3.1.    LRS will honor requests that are signed using OAuth with the registered application's credentials and with an empty token and token secret.
    3.2.    If this form of authentication is used to record Statements and no authority is specified, the LRS should record the authority as the Agent representing the registered application.
4.  Application not registered + known user:
    4.1.    Use a blank consumer secret.
    4.2.    Call "Temporary Credential" request.
    4.3.    Specify "consumer_name" and other usual parameters; User will then see "consumer_name" plus a warning that the identity of the application requesting authorization cannot be verified.
    4.4.    The LRS MUST record an authority that includes both that application and the authenticating user, as a group, since OAuth specifies an application.
5.  No application + known user
    5.1.    Use username/password combination that corresponds to an LRS login.
    5.2.    Authority to be recorded as the Agent identified by the login, unless:
        5.2.1.  other Authority is specified and
        5.2.2.  LRS trusts the known user to specify this Authority.
6.  No authorization
    6.1.    Requests should include headers for HTTP Basic Authentication based on a blank username and password, in order to distinguish an explicitly unauthenticated request from a request that should be given a HTTP Basic Authentication challenge.
7.  The LRS MUST be able to be configured for complete support of the xAPI:
    7.1.    With any of the above methods.
    7.2.    In any of the workflow scenarios above.
8.  The LRS MAY (for security reasons):
    8.1.    Support a subset of the above methods.
    8.2.    Limit the known users or registered applications.
9.  The LRS SHOULD at a minimum supply Oauth with "HMAC-SHA1" and "RSA-SHA1" signatures.

#### 6.4.2 OAuth Authorization Scope
1.  The LRS MUST accept a scope parameter as defined in OAuth 2.0.
2.  The LRS MUST assume a requested scope of "statements/write" and "statements/read/mine" if no scope is specified.
3.  The LRS MUST support the scope of "all" as a minimum.
4.  THE LRS MAY support other scopes.
5.  The LRS SHOULD request only the minimal needed scopes, to increase the chances that the request will be granted.
6.  Define scope - (re)Define Activities and Actors. If storing a Statement when this is not granted, ids will be saved and the LRS may save the original Statement for audit purposes, but should not update its internal representation of any Actors or Activities.

#### 7.0 Data Transfer (REST)
1.  The LRS MUST reject with HTTP 400 Bad Request status any request to any of these APIs using any parameters:
    1.1.  The LRS does not recognize ( Note: LRSs may recognize and act on parameters not in this specification).
    1.2.    That match parameters described in this specification in all but case.
#### 7.1 Error Codes
1.  An LRS MUST return the error code most appropriate to the error condition based on the list below, and SHOULD return a message in the response explaining the cause of the error.
    400 Bad Request - Indicates an error condition caused by an invalid or missing argument. The term "invalid arguments" includes malformed JSON or invalid Object structures.
    401 Unauthorized - Indicates that authentication is required, or in the case authentication has been posted in the request, that the given credentials have been refused.
    403 Forbidden - Indicates that the request is unauthorized for the given credentials. Note this is different than refusing the credentials given. In this case, the credentials have been validated, but the authenticated Client is not allowed to perform the given action.
    404 Not Found -Indicates the requested resource was not found. May be returned by any method that returns a uniquely identified resource, for instance, any State or Agent Profile or Activity Profile API call targeting a specific document, or the method to retrieve a single Statement.
    409 Conflict -Indicates an error condition due to a conflict with the current state of a resource, in the case of State API, Agent Profile or Activity Profile API calls, or in the Statement PUT call. See Section 6.3 Concurrency for more details.
    412 Precondition Failed - Indicates an error condition due to a failure of a precondition posted with the request, in the case of State or Agent Profile or Activity Profile API calls. See Section 6.3 Concurrency for more details.
    413 Request Entity Too Large - Indicates that the LRS has rejected the Statement or document because its size is larger than the maximum allowed by the LRS. The LRS is free to choose any limit and MAY vary this limit on any basis, e.g., per authority, but MUST be configurable to accept Statements of any size.
    500 Internal Server Error - Indicates a general error condition, typically an unexpected exception in processing on the server.

#### 7.2 Statement API
1.  For PUT and POST, an LRS MUST NOT make any modifications to its state based on a receiving a Statement with a statementID that it already has a Statement for. Whether it responds with 409 Conflict or 204 No Content,  it MUST NOT modify the Statement or any other Object. 
2.  For PUT and POST, if the LRS receives a Statement with an id it already has a Statement for, it SHOULD verify the received Statement matches the existing one and return 409 Conflict if they do not match.
3.  For PUT and POST, the LRS MAY respond before Statements that have been stored are available for retrieval.
4.  For GET, the LRS MUST reject with an HTTP 400 error any requests to this resource which:
    4.1.    Contain both statementId and voidedStatementId parameters.
    4.2.    Contain statementId or voidedStatementId parameters, and also contain any other parameter besides "attachments" or "format”.
5.  For GET, registration filter - Filter, only return Statements matching the specified registration id. Note that although frequently a unique registration id will be used for one Actor assigned to one Activity, this should not be assumed. If only Statements for a certain Actor or Activity should be returned, those parameters should also be specified.
6.  For GET, format filter - If "canonical", return Activity Objects populated with the canonical definition of the Activity Objects as determined by the LRS, after applying the language filtering process defined below, and return the original Agent Objects as in "exact" mode. Activity Objects contain Language Map Objects for name and description. Only one language should be returned in each of these maps. In order to provide these strings in the most relevant language, the LRS will apply the Accept-Language header as described in  RFC 2616 (HTTP 1.1), except that this logic will be applied to each language map individually to select which language entry to include, rather than to the resource (list of Statements) as a whole. An LRS requesting Statements for the purpose of importing them SHOULD use a format of "exact".
7.  The LRS MUST include the header "X-Experience-API-Consistent-Through", in ISO 8601 combined date and time format, on all responses to Statements requests, with a value of the timestamp for which all Statements that have or will have a "stored" property before that time are known with reasonable certainty to be available for retrieval. This time SHOULD take into account any temporary condition, such as excessive load, which might cause a delay in Statements becoming available for retrieval.
8.  Due to query string limits, this method MAY be called using POST and form fields if necessary. The LRS MUST differentiate a POST to add a Statement or to list Statements based on the parameters passed.
9.  The LRS MUST not return any Statement which has been voided, unless that Statement has been requested by voidedStatementId.
10. The LRS MUST still return any Statements targeting the voided Statement when retrieving Statements using explicit or implicit time or sequence based retrieval, unless they themselves have been voided, as described in the section on filter conditions for StatementRefs. This includes the voiding Statement, which cannot be voided. Reporting tools can identify the presence and statementId of any voided Statements by the target of the voiding Statement. Reporting tools wishing to retrieve voided Statements SHOULD request these individually by voidedStatementId.

#### 7.3 Document APIs
1.  When an LRS receives a POST request with content type application/json for an existing document also of content type application/json, it MUST merge the posted document with the existing document.
2.  If the original document exists, and the original document or the document being posted do not have a Content-Type: of "application/json", or if either document cannot be parsed as JSON Objects, the LRS MUST respond with HTTP status code 400 "Bad Request", and MUST NOT update the target document as a result of the request.
3.  If the original document does not exist, the LRS MUST treat the request the same as it would a PUT request and store the document being posted.
4.  If the merge is successful, the LRS MUST respond with HTTP status code 204 "No Content".

#### 7.6 Agent Profile API
1.  An LRS capable of returning multiple identifying properties for a Person Object SHOULD require the connecting credentials have increased, explicitly given permissions. An LRS SHOULD reject insufficiently privileged requests with 403 "Forbidden". If an LRS does not have any additional information about an Agent to return, the LRS MUST still return a Person when queried, but that Person Object will only include the information associated with the requested Agent.

#### 7.7 About Resource
1.  MUST return the JSON document described above, with a version property that includes the latest minor and patch version the LRS conforms to, for each major version.
2.  For version 1.0.0 of this specification, this means that "1.0.0" MUST be included; "0.9" and "0.95" MAY be included. (For the purposes of this requirement, "0.9" and "0.95" are considered major versions.)
3.  SHOULD allow unauthenticated access to this resource.
4.  MUST NOT reject requests based on their version header as would otherwise be required by 6.2 API Versioning.

#### 7.8 Cross Origin Requests
1.  All xAPI requests issued must be POST. The intended xAPI method must be included as the only query string parameter on the request. (example: http://example.com/xAPI/statements?method=PUT)
2.  Any required parameters which are expected to appear in the HTTP header must instead be included as a form parameter with the same name.
3.  If the xAPI call involved sending content, that content must now be encoded and included as a form parameter called "content". The LRS will interpret this content as a UTF-8 string. Storing binary data is not supported with this syntax.
4.  It should also be noted that versions of Internet Explorer lower than 10 do not support Cross Domain Requests between HTTP and HTTPS. This means that for IE9 and lower, if the LRS is on an HTTPS domain, the Client sending the Statement must also be on HTTPS. If the LRS is on HTTP, the Client must be too.
5.  There may be cases where there is a requirement for the Client Activity Provider to support IE8 and IE9 where the Client code is hosted on a different scheme (HTTP or HTTPS) from the LRS. In these cases, proxy is needed to communicate to the LRS. Two simple solutions might be to 1) set up a proxy pass through on the same scheme as the Client code to the LRS or 2) to host an intermediary server side LRS on the same scheme as the Client code to route Statements to the target LRS. An LRS MAY choose to provide both HTTP and HTTPS endpoints to support this use case. HTTP is inherently less secure than HTTPS, and both LRS and Client should consider the security risks before making the decision to use this scheme.

#### 7.9 Validation
1.  The function of the LRS within the xAPI is to store and retrieve Statements. As long as it has sufficient information to perform these tasks, it is expected that it does them. Validation of Statements in the Experience API is focused solely on syntax, not semantics. It SHOULD enforce rules regarding structure, but SHOULD NOT enforce rules regarding meaning. Enforcing the rules that ensure valid meaning among Verb definitions, Activity types, and extensions is the responsibility of the Activity Provider sending the Statement.

#### 7.10 HTTP HEAD
1.  The LRS MUST respond to any HTTP HEAD request as it would have responded to an otherwise identical HTTP GET request except:
2.  The message-body MUST be omitted
3.  The Content-Length header MAY be omitted, in order to avoid wasting LRS resources.

